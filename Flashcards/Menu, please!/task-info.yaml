type: edu
custom_name: stage5
files:
- name: src/flashcards/Main.kt
  visible: true
  text: |
    package flashcards

    fun main() {
        println("Hello, World!")
    }
  learner_created: false
- name: test/FlashcardsTest.java
  visible: false
  text: "import flashcards.MainKt;\nimport org.hyperskill.hstest.dynamic.input.DynamicTestingMethod;\n\
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;\nimport org.hyperskill.hstest.stage.StageTest;\n\
    import org.hyperskill.hstest.testcase.CheckResult;\nimport org.hyperskill.hstest.testcase.TestCase;\n\
    import org.hyperskill.hstest.testing.TestedProgram;\nimport org.junit.AfterClass;\n\
    import org.junit.BeforeClass;\n\nimport java.io.BufferedReader;\nimport java.io.File;\n\
    import java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\n\
    import java.util.List;\n\npublic class FlashcardsTest extends StageTest<String>\
    \ {\n    \n    private static List<String> listOfTerms;\n    private static List<String>\
    \ listOfDefinitions;\n    private static List<String> listOfAddedDefinitions;\n\
    \    private static List<String> listOfCountries;\n    private static List<String>\
    \ listOfCapitals;\n    private final String capitalsFile = \"capitals.txt\";\n\
    \    private final String capitalsNewFile = \"capitalsNew.txt\";\n    \n    @BeforeClass\n\
    \    public static void generateLists(){\n        listOfTerms = getListOfTerms();\n\
    \        listOfDefinitions = getListOfDefinitions();\n        listOfAddedDefinitions\
    \ = getListOfWrongDefinitions1();\n        listOfCountries = getListOfCountries();\n\
    \        listOfCapitals = getListOfCapitals();\n    }\n    \n    @AfterClass\n\
    \    public static void deleteFiles() {\n        File capitalsFile = new File(\"\
    capitals.txt\");\n        //noinspection ResultOfMethodCallIgnored\n        capitalsFile.delete();\n\
    \n        File capitalsNewFile = new File(\"capitalsNew.txt\");\n        //noinspection\
    \ ResultOfMethodCallIgnored\n        capitalsNewFile.delete();\n\n    }\n    \n\
    \    @DynamicTestingMethod\n    CheckResult test1() {\n        TestedProgram main\
    \ = new TestedProgram(MainKt.class);\n        \n        String output = main.start().toLowerCase().trim();\n\
    \        if (!output.contains(\"input the action\")) {\n            return CheckResult.wrong(\"\
    Your program should prompt the user for an action with the message \\\"Input the\
    \ \" +\n                    \"action\\\"\");\n        }\n        \n        output\
    \ = main.execute(\"exit\").toLowerCase();\n        if (!output.contains(\"bye\
    \ bye\")) {\n            return CheckResult.wrong(\"Your program should print\
    \ \\\"Bye bye!\\\" and terminate if the user enters \" +\n                   \
    \ \"\\\"exit\\\"\");\n        }\n        \n        if (!main.isFinished()) {\n\
    \            return CheckResult.wrong(\"Your program should terminate if the user\
    \ enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    //Test to check the \"add\" action\n    @DynamicTestingMethod\n\
    \    CheckResult test2() {\n        TestedProgram main = new TestedProgram(MainKt.class);\n\
    \        main.start();\n        \n        String output;\n        String lastLine;\n\
    \        String[] lines;\n        \n        output = main.execute(\"add\").toLowerCase();\n\
    \        if (!output.contains(\"card\")) {\n            return CheckResult.wrong(\"\
    Your program should prompt the user for the name of the card with the message\
    \ \" +\n                    \"\\\"The card:\\\"\");\n        }\n        \n   \
    \     output = main.execute(\"France\").toLowerCase();\n        if (!output.contains(\"\
    definition of the card\")) {\n            return CheckResult.wrong(\"Your program\
    \ should prompt the user for the definition of the card with the \" +\n      \
    \              \"message \\\"The definition of the card:\\\"\");\n        }\n\
    \        \n        output = main.execute(\"Paris\").toLowerCase();\n        if\
    \ (!output.contains(\"pair (\\\"france\\\":\\\"paris\\\") has been added\")) {\n\
    \            return CheckResult.wrong(\"Your program should print the message\
    \ \\\"The pair (\\\"term\\\":\\\"definition\\\") has \" +\n                  \
    \  \"been added\\\" after adding a card successfully\");\n        }\n        \n\
    \        lines = output.split(\"\\n\");\n        lastLine = lines[lines.length\
    \ - 1];\n        if (!lastLine.contains(\"input the action\")) {\n           \
    \ return CheckResult.wrong(\"Your program should continue to request an action\
    \ from the user until they \" +\n                    \"enter \\\"exit\\\"\");\n\
    \        }\n        \n        main.execute(\"add\");\n        output = main.execute(\"\
    France\").toLowerCase();\n        if (!output.contains(\"card \\\"france\\\" already\
    \ exists\")) {\n            return CheckResult.wrong(\"Your program should not\
    \ add a card that already exists and should notify the \" +\n                \
    \    \"user with the message \\\"The card 'term' already exists\\\".\");\n   \
    \     }\n        \n        lines = output.split(\"\\n\");\n        lastLine =\
    \ lines[lines.length - 1];\n        if (!lastLine.contains(\"input the action\"\
    )) {\n            return CheckResult.wrong(\"Your program should request an action\
    \ from the user if a card was declined \" +\n                    \"because it\
    \ already exists\");\n        }\n        \n        main.execute(\"add\");\n  \
    \      main.execute(\"Great Britain\");\n        output = main.execute(\"Paris\"\
    ).toLowerCase();\n        if (!output.contains(\"definition \\\"paris\\\" already\
    \ exists\")) {\n            return CheckResult.wrong(\"Your program should not\
    \ add a definition that already exists and should notify \" +\n              \
    \      \"the \\\"user with the message \\\"The definition 'definition' already\
    \ exists\\\".\");\n        }\n        \n        output = main.execute(\"exit\"\
    ).toLowerCase();\n        if (!output.contains(\"bye\")) {\n            return\
    \ CheckResult.wrong(\"Your program should print \\\"Bye bye!\\\" and terminate\
    \ if the user enters \" +\n                    \"\\\"exit\\\"\");\n        }\n\
    \        \n        if (!main.isFinished()) {\n            return CheckResult.wrong(\"\
    Your program should termiante if the user enters \\\"exit\\\"\");\n        }\n\
    \        \n        return CheckResult.correct();\n    }\n    \n    //Test to check\
    \ the \"remove\" action\n    @DynamicTestingMethod\n    CheckResult test3() {\n\
    \        TestedProgram main = new TestedProgram(MainKt.class);\n        main.start();\n\
    \        \n        String output;\n        String lastLine;\n        String[]\
    \ lines;\n        \n        //No need to check user's output because they have\
    \ been checked in test 2.\n        main.execute(\"add\");\n        main.execute(\"\
    France\");\n        main.execute(\"Paris\");\n        \n        main.execute(\"\
    add\");\n        main.execute(\"Japan\");\n        main.execute(\"Tokyo\");\n\
    \        \n        main.execute(\"add\");\n        main.execute(\"Great Britain\"\
    );\n        main.execute(\"London\");\n        \n        output = main.execute(\"\
    remove\").toLowerCase();\n        if (!output.contains(\"which card\")) {\n  \
    \          return CheckResult.wrong(\"Your program should prompt the user for\
    \ the name of the card with the message \" +\n                    \"\\\"Which\
    \ card?\\\"\");\n        }\n        \n        output = main.execute(\"Japan\"\
    ).toLowerCase();\n        if (!output.contains(\"card has been removed\")) {\n\
    \            return CheckResult.wrong(\"Your program should notify the user with\
    \ the message \" +\n                    \"\\\"The card has been removed.\\\" if\
    \ the card was removed successfully\");\n        }\n        \n        lines =\
    \ output.split(\"\\n\");\n        lastLine = lines[lines.length - 1];\n      \
    \  if (!lastLine.contains(\"input the action\")) {\n            return CheckResult.wrong(\"\
    Your program should continue to request an action from the user until they \"\
    \ +\n                    \"enter \\\"exit\\\"\");\n        }\n        \n     \
    \   main.execute(\"remove\");\n        output = main.execute(\"Wakanda\").toLowerCase();\n\
    \        if (!output.contains(\"can't remove \\\"wakanda\\\"\")) {\n         \
    \   return CheckResult.wrong(\"Your program should notify the user with the message\"\
    \ +\n                    \" \\\"Can't remove 'card': there is no such card.\\\"\
    \ if the card doesn't exist\");\n        }\n        \n        if (!output.contains(\"\
    no such card\")) {\n            return CheckResult.wrong(\"Your program should\
    \ notify the user with the message\" +\n                    \" \\\"Can't remove\
    \ 'card': there is no such card.\\\" if the card doesn't exist\");\n        }\n\
    \        \n        lines = output.split(\"\\n\");\n        lastLine = lines[lines.length\
    \ - 1];\n        if (!lastLine.contains(\"input the action\")) {\n           \
    \ return CheckResult.wrong(\"Your program should request an action from the user\
    \ even if a card could not be\" +\n                    \" removed\");\n      \
    \  }\n        \n        main.execute(\"remove\");\n        output = main.execute(\"\
    Tokyo\").toLowerCase();\n        if (output.contains(\"card has been removed\"\
    )) {\n            return CheckResult.wrong(\"You should not be able to remove\
    \ a card by it's definition\");\n        }\n    \n        output = main.execute(\"\
    exit\").toLowerCase();\n        if (!output.contains(\"bye\")) {\n           \
    \ return CheckResult.wrong(\"Your program should print \\\"Bye bye!\\\" and terminate\
    \ if the user enters \" +\n                    \"\\\"exit\\\"\");\n        }\n\
    \    \n        if (!main.isFinished()) {\n            return CheckResult.wrong(\"\
    Your program should termiante if the user enters \\\"exit\\\"\");\n        }\n\
    \        \n        return CheckResult.correct();\n    }\n    \n    //Test to check\
    \ \"export\" action\n    @DynamicTestingMethod\n    CheckResult test4() {\n  \
    \      TestedProgram main = new TestedProgram(MainKt.class);\n        main.start();\n\
    \        \n        String output;\n        String lastLine;\n        String[]\
    \ lines;\n        boolean fileExists;\n        boolean empty;\n        \n    \
    \    main.execute(\"add\");\n        main.execute(\"Japan\");\n        main.execute(\"\
    Tokyo\");\n        \n        main.execute(\"add\");\n        main.execute(\"France\"\
    );\n        main.execute(\"Paris\");\n        \n        output = main.execute(\"\
    export\").toLowerCase();\n        if (!output.contains(\"file name\")) {\n   \
    \         return CheckResult.wrong(\"Your program should prompt the user for the\
    \ name of the file with the message \" +\n                    \"\\\"File name:\\\
    \"\");\n        }\n        \n        output = main.execute(capitalsFile).toLowerCase();\n\
    \        if (!output.contains(\"2 cards\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were exported. Expected 2\");\n        }\n        \n   \
    \     if (!output.contains(\"saved\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the cards were exported with the message\
    \ \" +\n                    \"\\\"n cards have been saved.\\\" where \\\"n\\\"\
    \ is the number of cards exported\");\n        }\n        \n        fileExists\
    \ = checkFileExistence(capitalsFile);\n        if (!fileExists) {\n          \
    \  return CheckResult.wrong(\"Your program did not save a file after exporting\"\
    );\n        }\n        \n        empty = isEmpty(capitalsFile);\n        if (empty)\
    \ {\n            return CheckResult.wrong(\"The file your program saves is empty\"\
    );\n        }\n        \n        lines = output.split(\"\\n\");\n        lastLine\
    \ = lines[lines.length - 1];\n        if (!lastLine.contains(\"input the action\"\
    )) {\n            return CheckResult.wrong(\"Your program should continue to request\
    \ an action from the user until they \" +\n                    \"enter \\\"exit\\\
    \"\");\n        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n\
    \        if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should termiante if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    //saves file for the next test\n    @DynamicTestingMethod\n\
    \    CheckResult test5() {\n        TestedProgram main = new TestedProgram(MainKt.class);\n\
    \        main.start();\n        \n        String output;\n        boolean fileExists;\n\
    \        boolean empty;\n        \n        for (int i = 0; i < listOfCountries.size();\
    \ i++) {\n            main.execute(\"add\");\n            main.execute(listOfCountries.get(i));\n\
    \            main.execute(listOfCapitals.get(i));\n        }\n        \n     \
    \   main.execute(\"export\");\n        output = main.execute(capitalsNewFile).toLowerCase();\n\
    \        if (!output.contains(\"6 cards\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were exported. Expected 6\");\n        }\n        \n   \
    \     if (!output.contains(\"saved\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the cards were exported with the message\"\
    \ +\n                    \" \\\"n cards have been saved.\\\" where \\\"n\\\" is\
    \ the number of cards exported\");\n        }\n        \n        fileExists =\
    \ checkFileExistence(capitalsNewFile);\n        if (!fileExists) {\n         \
    \   return CheckResult.wrong(\"Your program did not save a file after exporting\"\
    );\n        }\n        \n        empty = isEmpty(capitalsNewFile);\n        if\
    \ (empty) {\n            return CheckResult.wrong(\"The file your program saves\
    \ is empty\");\n        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n\
    \        if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should termiante if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    //Test to check \"import\" action\n    @DynamicTestingMethod\n\
    \    CheckResult test6() {\n        TestedProgram main = new TestedProgram(MainKt.class);\n\
    \        main.start();\n        \n        String output;\n        String lastLine;\n\
    \        String[] lines;\n        boolean fileExists;\n        boolean empty;\n\
    \        \n        output = main.execute(\"import\").toLowerCase();\n        if\
    \ (!output.contains(\"file name\")) {\n            return CheckResult.wrong(\"\
    Your program should prompt the user for the name of the file with the message\
    \ \" +\n                    \"\\\"File name:\\\"\");\n        }\n        \n  \
    \      String nonExistentFile = \"ghost_file.txt\";\n        output = main.execute(nonExistentFile).toLowerCase();\n\
    \        if (!output.contains(\"not found\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the file does not exist with the message\"\
    \ +\n                    \" \\\"File not found.\\\"\");\n        }\n        \n\
    \        lines = output.split(\"\\n\");\n        lastLine = lines[lines.length\
    \ - 1];\n        if (!lastLine.contains(\"input the action\")) {\n           \
    \ return CheckResult.wrong(\"Your program should continue to request an action\
    \ from the user until they \" +\n                    \"enter \\\"exit\\\"\");\n\
    \        }\n        \n        main.execute(\"import\");\n        output = main.execute(capitalsFile).toLowerCase();\n\
    \        if (output.contains(\"not found\")) {\n            return CheckResult.wrong(\"\
    You should be able to import a file that you previously saved.\");\n        }\n\
    \        \n        if (!output.contains(\"2 cards\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were imported. Expected 2\");\n        }\n        \n   \
    \     if (!output.contains(\"been loaded\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the cards were imported with the message\"\
    \ +\n                    \" \\\"n cards have been loaded.\\\" where \\\"n\\\"\
    \ is the number of cards in the file\");\n        }\n        \n        lines =\
    \ output.split(\"\\n\");\n        lastLine = lines[lines.length - 1];\n      \
    \  if (!lastLine.contains(\"input the action\")) {\n            return CheckResult.wrong(\"\
    Your program should continue to request an action from the user until they \"\
    \ +\n                    \"enter \\\"exit\\\"\");\n        }\n        \n     \
    \   main.execute(\"remove\");\n        output = main.execute(\"Japan\").toLowerCase();\n\
    \        if (!output.contains(\"card has been removed\")) {\n            return\
    \ CheckResult.wrong(\"You should be able to remove a card that you imported from\
    \ a file\");\n        }\n        \n        main.execute(\"export\");\n       \
    \ output = main.execute(capitalsFile).toLowerCase();\n        if (!output.contains(\"\
    1 card\")) {\n            return CheckResult.wrong(\"Wrong number of cards were\
    \ exported. Expected 1\");\n        }\n        \n        main.execute(\"import\"\
    );\n        output = main.execute(capitalsNewFile).toLowerCase();\n        if\
    \ (!output.contains(\"6 cards\")) {\n            return CheckResult.wrong(\"Wrong\
    \ number of cards were imported. Expected 6\");\n        }\n        \n       \
    \ main.execute(\"export\");\n        output = main.execute(capitalsNewFile).toLowerCase();\n\
    \        if (!output.contains(\"7 cards\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were exported. Expected 7\");\n        }\n        \n   \
    \     fileExists = checkFileExistence(capitalsNewFile);\n        if (!fileExists)\
    \ {\n            return CheckResult.wrong(\"Your program did not save a file after\
    \ exporting\");\n        }\n        \n        empty = isEmpty(capitalsNewFile);\n\
    \        if (empty) {\n            return CheckResult.wrong(\"The file your program\
    \ saves is empty\");\n        }\n    \n        output = main.execute(\"exit\"\
    ).toLowerCase();\n        if (!output.contains(\"bye\")) {\n            return\
    \ CheckResult.wrong(\"Your program should print \\\"Bye bye!\\\" and terminate\
    \ if the user enters \" +\n                    \"\\\"exit\\\"\");\n        }\n\
    \    \n        if (!main.isFinished()) {\n            return CheckResult.wrong(\"\
    Your program should termiante if the user enters \\\"exit\\\"\");\n        }\n\
    \        \n        return CheckResult.correct();\n    }\n    \n    //Test to check\
    \ \"ask\" action\n    @DynamicTestingMethod\n    CheckResult test7() {\n     \
    \   TestedProgram main = new TestedProgram(MainKt.class);\n        main.start();\n\
    \        \n        String output;\n        String lastLine;\n        String[]\
    \ lines;\n        \n        main.execute(\"add\");\n        main.execute(\"France\"\
    );\n        main.execute(\"Eiffel Tower\");\n        \n        main.execute(\"\
    import\");\n        output = main.execute(capitalsFile).toLowerCase();\n     \
    \   if (!output.contains(\"1 card\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were imported. Expected 1\");\n        }\n        \n   \
    \     if (!output.contains(\"been loaded\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the cards were imported with the message\"\
    \ +\n                    \" \\\"n cards have been loaded.\\\" where \\\"n\\\"\
    \ is the number of cards in the file\");\n        }\n        \n        output\
    \ = main.execute(\"ask\").toLowerCase();\n        if (!output.contains(\"times\"\
    )) {\n            return CheckResult.wrong(\"Your program should prompt the user\
    \ for the number of cards they want to be \" +\n                    \"asked about\
    \ with the message \\\"How many times to ask?\\\"\");\n        }\n        \n \
    \       \n        output = main.execute(\"1\").toLowerCase();\n        if (!output.contains(\"\
    \\\"france\\\"\")) {\n            return CheckResult.wrong(\"Your program should\
    \ print the definition requested for in quotes\");\n        }\n        \n    \
    \    if (!output.contains(\"definition\")) {\n            return CheckResult.wrong(\"\
    Your program should prompt the user for the definition of a card with the \" +\n\
    \                    \"message \\\" Print the definition of \\\"term\\\": where\
    \ \\\"term\\\" is the term of the flashcard to be \" +\n                    \"\
    checked\");\n        }\n        \n        output = main.execute(\"Eiffel Tower\"\
    ).toLowerCase();\n        if (output.equals(\"correct!\")) {\n            return\
    \ CheckResult.wrong(\"If the program's memory already has a card that is also\
    \ contained in the file \" +\n                    \"imported, then the definition\
    \ of the card from the file should overwrite the one in the \" +\n           \
    \         \"program's memory\");\n        }\n        \n        if (!output.contains(\"\
    wrong. the right answer is \\\"paris\\\"\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Wrong\\\" followed by the correct definition in\
    \ quotes\" +\n                    \" if the user inputs the wrong definition\"\
    );\n        }\n        \n        lines = output.split(\"\\n\");\n        lastLine\
    \ = lines[lines.length - 1];\n        if (!lastLine.contains(\"input the action\"\
    )) {\n            return CheckResult.wrong(\"Your program should request an action\
    \ from the user if there are no more cards \" +\n                    \"to ask\"\
    );\n        }\n        \n        main.execute(\"ask\");\n        main.execute(\"\
    1\");\n        output = main.execute(\"Paris\").toLowerCase();\n        lines\
    \ = output.split(\"\\n\");\n        \n        if (!lines[0].equals(\"correct!\"\
    )) {\n            return CheckResult.wrong(\"Your program should print \\\"Correct!\\\
    \" if the user inputs the correct \" +\n                    \"definition\");\n\
    \        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n   \
    \     if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should termiante if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    @DynamicTestingMethod\n    CheckResult test8() {\n        TestedProgram\
    \ main = new TestedProgram(MainKt.class);\n        main.start();\n        \n \
    \       int index;\n        String output;\n        String term;\n        String\
    \ lastLine;\n        String[] lines;\n        \n        for (int i = 0; i < listOfTerms.size();\
    \ i++) {\n            main.execute(\"add\");\n            main.execute(listOfTerms.get(i));\n\
    \            main.execute(listOfDefinitions.get(i));\n        }\n        \n  \
    \      main.execute(\"ask\");\n        output = main.execute(\"6\").toLowerCase();\n\
    \        term = getTerm(output);\n        \n        for (int i = 0; i < listOfTerms.size();\
    \ i++){\n            index = listOfTerms.indexOf(term);\n\n            if (index\
    \ == -1) {\n                return CheckResult.wrong(\"The card \\\"\" + term\
    \ + \"\\\" wasn't added, but you ask to enter its definition!\");\n          \
    \  }\n\n            output = main.execute(listOfDefinitions.get(index)).toLowerCase();\n\
    \            lines = output.split(\"\\n\");\n            lastLine = lines[lines.length\
    \ - 1];\n            \n            if (!lines[0].equals(\"correct!\")) {\n   \
    \             return CheckResult.wrong(\"Your program should print \\\"Correct!\\\
    \" if the user inputs the correct\" +\n                        \" definition\"\
    );\n            }\n            \n            if (i == listOfTerms.size() - 1)\
    \ {\n                \n                if (!lastLine.contains(\"input the action\"\
    )) {\n                    return CheckResult.wrong(\"Your program should request\
    \ an action from the user if there are no more cards \" +\n                  \
    \          \"to ask\");\n                }\n            } else {\n           \
    \     term = getTerm(lastLine);\n            }\n            \n        }\n    \n\
    \        output = main.execute(\"exit\").toLowerCase();\n        if (!output.contains(\"\
    bye\")) {\n            return CheckResult.wrong(\"Your program should print \\\
    \"Bye bye!\\\" and terminate if the user enters \" +\n                    \"\\\
    \"exit\\\"\");\n        }\n    \n        if (!main.isFinished()) {\n         \
    \   return CheckResult.wrong(\"Your program should termiante if the user enters\
    \ \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    @DynamicTestingMethod\n    CheckResult test9() {\n        TestedProgram\
    \ main = new TestedProgram(MainKt.class);\n        main.start();\n        \n \
    \       int index;\n        String output;\n        String term;\n        String\
    \ lastLine;\n        String[] lines;\n        \n        for (int i = 0; i < listOfTerms.size();\
    \ i++) {\n            main.execute(\"add\");\n            main.execute(listOfTerms.get(i));\n\
    \            main.execute(listOfDefinitions.get(i));\n        }\n        \n  \
    \      main.execute(\"ask\");\n        output = main.execute(\"6\").toLowerCase();\n\
    \        term = getTerm(output);\n        \n        for (int i = 0; i < listOfTerms.size();\
    \ i++){\n            index = listOfTerms.indexOf(term);\n\n            if (index\
    \ == -1) {\n                return CheckResult.wrong(\"The card \\\"\" + term\
    \ + \"\\\" wasn't added, but you ask to enter its definition!\");\n          \
    \  }\n            \n            output = main.execute(listOfAddedDefinitions.get(index)).toLowerCase();\n\
    \            lines = output.split(\"\\n\");\n            lastLine = lines[lines.length\
    \ - 1];\n            \n            if (!lines[0].contains(\"wrong. the right answer\
    \ is \\\"\" + listOfDefinitions.get(index) + \"\\\"\")) {\n                return\
    \ CheckResult.wrong(\"Your program should print \\\"Wrong\\\" followed by the\
    \ correct definition\" +\n                        \" in quotes if the user inputs\
    \ the wrong definition\");\n            }\n            \n            if (i ==\
    \ listOfTerms.size() - 1) {\n                \n                if (!lastLine.contains(\"\
    input the action\")) {\n                    return CheckResult.wrong(\"Your program\
    \ should request an action from the user if there are no more cards \" +\n   \
    \                         \"to ask\");\n                }\n            } else\
    \ {\n                term = getTerm(lastLine);\n            }\n            \n\
    \        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n   \
    \     if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should termiante if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    @DynamicTestingMethod\n    CheckResult test10() {\n        TestedProgram\
    \ main = new TestedProgram(MainKt.class);\n        main.start();\n        \n \
    \       int wrongIndex;\n        int index;\n        String output;\n        String\
    \ term;\n        String lastLine;\n        String[] lines;\n        \n       \
    \ for (int i = 0; i < listOfTerms.size(); i++) {\n            main.execute(\"\
    add\");\n            main.execute(listOfTerms.get(i));\n            main.execute(listOfDefinitions.get(i));\n\
    \        }\n        \n        main.execute(\"ask\");\n        output = main.execute(\"\
    6\").toLowerCase();\n        term = getTerm(output);\n        \n        for (int\
    \ i = 0; i < listOfTerms.size(); i++){\n            index = listOfTerms.indexOf(term);\n\
    \n            if (index == -1) {\n                return CheckResult.wrong(\"\
    The card \\\"\" + term + \"\\\" wasn't added, but you ask to enter its definition!\"\
    );\n            }\n\n            wrongIndex = index == listOfDefinitions.size()\
    \ - 1 ? index - 1 : index + 1;\n            \n            output = main.execute(listOfDefinitions.get(wrongIndex)).toLowerCase();\n\
    \            lines = output.split(\"\\n\");\n            lastLine = lines[lines.length\
    \ - 1];\n            \n            if (!lines[0].contains(\"wrong. the right answer\
    \ is \\\"\" + listOfDefinitions.get(index) + \"\\\"\")) {\n                return\
    \ CheckResult.wrong(\"Your program should print \\\"Wrong\\\" followed by the\
    \ correct definition\" +\n                        \" in quotes if the user inputs\
    \ the wrong definition\");\n            }\n            \n            if (!lines[0].contains(\"\
    correct for \\\"\" + listOfTerms.get(wrongIndex) + \"\\\"\")) {\n            \
    \    return CheckResult.wrong(\"Your output should also contain \\\"but your definition\
    \ is correct for 'term'\" +\n                        \" \\\"\");\n           \
    \ }\n            \n            if (i == listOfTerms.size() - 1) {\n          \
    \      if (!lastLine.contains(\"input the action\")) {\n                    return\
    \ CheckResult.wrong(\"Your program should request an action from the user if there\
    \ are no more cards \" +\n                            \"to ask\");\n         \
    \       }\n            } else {\n                term = getTerm(lastLine);\n \
    \           }\n        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n\
    \        if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should termiante if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    private boolean checkFileExistence(String fileName) {\n    \
    \    File file = new File(fileName);\n        return file.exists();\n    }\n \
    \   \n    private boolean isEmpty(String fileName) {\n        int lineCount =\
    \ 0;\n        \n        File file = new File(fileName);\n        try (BufferedReader\
    \ reader = new BufferedReader(new FileReader(file))) {\n            \n       \
    \     while (reader.readLine() != null) {\n                lineCount++;\n    \
    \        }\n        }catch (IOException e) {\n        \n        }\n        \n\
    \        return lineCount <= 0;\n    }\n    \n    private String getTerm(String\
    \ output) {\n        int start = output.indexOf(\"\\\"\");\n        int end =\
    \ output.lastIndexOf(\"\\\"\");\n\n        if (start == -1 || end == - 1) {\n\
    \            throw new WrongAnswer(\"The card should be surrounded with \\\"\\\
    \" when you ask to print its definition!\\n\" +\n                \"For example:\
    \ Print the definition of \\\"str()\\\"\");\n        }\n        \n        return\
    \ output.substring((start + 1), end);\n    }\n    \n    private static List<String>\
    \ getListOfTerms() {\n        return Arrays.asList(\n                \"print()\"\
    ,\n                \"str()\",\n                \"son\",\n                \"daughter\"\
    ,\n                \"uncle\",\n                \"ankle\");\n    }\n    \n    private\
    \ static List<String> getListOfDefinitions() {\n        return Arrays.asList(\n\
    \                \"outputs text\",\n                \"converts to a string\",\n\
    \                \"a male child\",\n                \"a female child\",\n    \
    \            \"a brother of one's parent\",\n                \"a part of the body\
    \ where the foot and the leg meet\"\n        );\n    }\n    \n    //Extra wrongs\
    \ invalidate the definition\n    private static List<String> getListOfWrongDefinitions1()\
    \ {\n        return Arrays.asList(\n                \"outputs text line by line\"\
    ,\n                \"converts to a string and an integer\",\n                \"\
    a male child or a female child\",\n                \"a female child or a male\
    \ child\",\n                \"a brother of one's parent or grandparents\",\n \
    \               \"a part of the body where the foot and the leg meet or the arm\"\
    \n        );\n    }\n    \n    private static List<String> getListOfCountries()\
    \ {\n        return Arrays.asList(\n                \"Canada\",\n            \
    \    \"Netherlands\",\n                \"Russia\",\n                \"United Kingdom\"\
    ,\n                \"Nigeria\",\n                \"Germany\"\n        );\n   \
    \ }\n    \n    private static List<String> getListOfCapitals() {\n        return\
    \ Arrays.asList(\n                \"Ottawa\",\n                \"Amsterdam\",\n\
    \                \"Moscow\",\n                \"London\",\n                \"\
    Abuja\",\n                \"Berlin\"\n        );\n    }\n    \n}\n\n\n\n\n\n\n\
    \n\n\n\n\n"
  learner_created: false
- name: test/DialogClue.kt
  visible: false
  text: |
    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testcase.TestCase


    // ---- DialogClue ----

    /** May be several lines or just one. */
    interface Phrase {
        fun toPhraseLines(): List<PhraseLine>
    }

    /** list of input and output lines, combined together. */
    fun compositePhrase(block: () -> List<Phrase>) = object : Phrase {
        override fun toPhraseLines() = block().flatMap { it.toPhraseLines() }
    }

    fun compositePhrase(vararg phrases: Phrase) = object : Phrase {
        override fun toPhraseLines() = phrases.flatMap { it.toPhraseLines() }
    }

    /** Either user (input) or output phrase. Each phrase should be a line. */
    sealed class PhraseLine : Phrase {
        override fun toPhraseLines() = listOf(this)
    }

    /** Some mutable data, that is passed across dialog phrases. */
    class Context {
        val rawData = mutableMapOf<String, Any>()
    }

    class UserLine(val text: String, val updateContext: CtxUpdate = {}) : PhraseLine() {

    }
    typealias CtxUpdate = (ctx: Context) -> Unit

    class OutputLine(val checker: (text: String, ctx: Context) -> CheckResult) : PhraseLine()

    /** This function creates a line with user input (our test input).
     *
     * Unfortunately we can't access the Context, when we adding user text.
     * This occurs because of HS test framework limitations:
     * we need to pass all inputs first, and then start checking outputs. */
    fun user(text: String, updateContext: (ctx: Context) -> Unit = {}) = UserLine(text, updateContext)

    fun anyLine() = OutputLine { _, _ -> CheckResult.correct(); }

    fun containing(
            vararg parts: String,
            ignoreCase: Boolean = true,
            hint: String? = null,
            updateContext: CtxUpdate = {}
    ) = OutputLine { line, context ->
        fun buildFeedback(): String {
            val feedback = StringBuilder()
            feedback.append("Your line\n`$line`\nshould contain ${parts.joinToString("`, `", "`", "`")}")
            if (ignoreCase) {
                feedback.append(" (ignoring case)")
            }
            feedback.append(".")
            if (hint != null) {
                feedback.append("\n$hint")
            }
            return feedback.toString()
        }

        var startIndex = 0
        for (part in parts) {
            startIndex = line.indexOf(part, startIndex, ignoreCase)
            if (startIndex == -1) {
                return@OutputLine CheckResult.wrong(buildFeedback())
            }
        }
        updateContext(context) // everything is correct, update context
        CheckResult.correct();
    }

    class DialogClue(private val phrases: List<PhraseLine>) {

        private val inputPhrases = phrases.filter { it is UserLine }.map { it as UserLine }
        private val outputPhrases = phrases.filter { it is OutputLine }.map { it as OutputLine }

        fun generateInput() = inputPhrases
                .joinToString("\n", postfix = "\n") { it.text }

        fun checkOutput(output: String): CheckResult {
            val lines = output.lines()
                    .filter { it.isNotBlank() }

            fun wrongOutputSizeFeedback() = CheckResult.wrong("The number of lines in your output is ${lines.size}, " +
                    "but it should be ${outputPhrases.size}. " +
                    "Check, that you output your lines with println, not print. And there are no extra outputs.")

    // here we store some mutable data from phrase to phrase
            val context = Context()

            val lineIter = lines.listIterator()
            phrases.forEach { phraseLine ->
                when (phraseLine) {
                    is UserLine -> phraseLine.updateContext(context)
                    is OutputLine -> {
                        if (!lineIter.hasNext()) {
                            return wrongOutputSizeFeedback()
                        }

                        val line: String = lineIter.next()
                        val result = phraseLine.checker(line, context)
                        if (!result.isCorrect) {
                            return CheckResult.wrong(result.feedback)
                        }
                    }
                }
            }

            if (lineIter.hasNext()) {
                return wrongOutputSizeFeedback()
            }

            return CheckResult.correct();
        }
    }

    fun dialogTest(vararg phrases: Phrase): TestCase<DialogClue> {
        val dialogClue = DialogClue(phrases.flatMap { it.toPhraseLines() })
        return TestCase<DialogClue>()
                .setInput(dialogClue.generateInput())
                .setAttach(dialogClue)
    }
  learner_created: false
- name: test/FlashcardsStage5Test.kt
  visible: false
  text: "import org.hyperskill.hstest.testcase.CheckResult\nimport org.hyperskill.hstest.testcase.TestCase\n\
    \nclass FlashcardsStage5Test : FlashcardsTest<DialogClue>() {\n\n    // how to\
    \ remove files? Now at least rewrite in the first test:\n    override fun generate():\
    \ List<TestCase<DialogClue>> {\n        val tests = mutableListOf<TestCase<DialogClue>>()\n\
    \        // old tests:\n        tests += dialogTest(\n                addCard(\"\
    black\", \"white\"),\n                existingCard(\"black\"),\n             \
    \   existingDef(\"red\", \"white\"),\n                askCards(\"white\", \"green\"\
    ), // the ask order is random\n                exit()\n        )\n        tests\
    \ += dialogTest(\n                addCard(\"a brother of one's parent\", \"uncle\"\
    ),\n                addCard(\"a part of the body where the foot and the leg meet\"\
    , \"ankle\"),\n                askCards(\"ankle\", \"??\", \"uncle\", \"ankle\"\
    , \"??\", \"uncle\"), // the ask order is random\n                exit()\n   \
    \     )\n        // stage 5 tests:\n\n        val capitalList = mutableListOf<Pair<String,\
    \ String>>()\n        fun capitals() = capitalList.toTypedArray()\n\n        //\
    \ wrappers for add/remove card, but saving cards to capitalList:\n        fun\
    \ addCapital(card: String, def: String) = addCard(card, def)\n               \
    \ .also { capitalList += card to def }\n\n        fun removeCapitalCard(card:\
    \ String) = removeCard(card)\n                .also { capitalList.removeIf { it.first\
    \ == card } }\n\n        // testing files\n        // clear files\n        tests\
    \ += dialogTest(\n                exportCards(\"capitals.txt\", 0),\n        \
    \        exportCards(\"capitalsNew.txt\", 0),\n                exit()\n      \
    \  )\n        tests += dialogTest(\n                importNonExisting(\"ghost_file.txt\"\
    ),\n                exit()\n        )\n        tests += dialogTest(\n        \
    \        addCapital(\"Great Britain\", \"London\"),\n                removeNonExisting(\"\
    Wakanda\"),\n                exportCards(\"capitals.txt\", 1),\n             \
    \   importCards(\"capitals.txt\", *capitals()),\n                askCards(\"London\"\
    ),\n                exportCards(\"capitalsNew.txt\", 1),\n                exit()\n\
    \        )\n        tests += dialogTest(\n                importCards(\"capitalsNew.txt\"\
    , *capitals()), // import checks only the amount of cards\n                exit()\n\
    \        )\n        tests += dialogTest(\n                importCards(\"capitalsNew.txt\"\
    , *capitals()),\n                addCapital(\"France\", \"Paris\"),\n        \
    \        addCapital(\"Russia\", \"Moscow\"),\n                removeCapitalCard(\"\
    Great Britain\"),\n                exportCards(\"capitalsNew.txt\", 2),\n    \
    \            importCards(\"capitalsNew.txt\", *capitals()),\n                askCards(\"\
    London\", \"Paris\", \"Moscow\", \"Paris\"),\n                exit()\n       \
    \ )\n        // check merge with file import\n        tests += dialogTest(\n \
    \               addCard(\"Japan\", \"Tokyo\"), // should be merged\n         \
    \       addCard(\"France\", \"UpdateMeFromImport\"), // should be updated from\
    \ import file\n                addCard(\"Russia\", \"UpdateMeFromImport2\"), //\
    \ should be updated from import file\n                importCards(\"capitalsNew.txt\"\
    , *capitals()),\n                askCards(\"Tokyo\", \"Paris\", \"Moscow\"),\n\
    \                removeCard(\"Japan\"),\n                removeCapitalCard(\"\
    Russia\"),\n                exportCards(\"capitalsNew.txt\", 1), // only France\
    \ left\n                exit()\n        )\n\n        // check reverse map while\
    \ merge\n        tests += dialogTest(\n                addCard(\"France\", \"\
    UpdateMeFromImport\"), // should be updated from import file\n               \
    \ importCards(\"capitalsNew.txt\", *capitals()),\n                askCards(\"\
    UpdateMeFromImport\"), // check that we removed from reverse map\n           \
    \     exit()\n        )\n        \n        // check remove, add and ask:\n   \
    \     tests += dialogTest(\n                addCard(\"a\", \"1\"),\n         \
    \       addCard(\"b\", \"2\"),\n                addCard(\"c\", \"3\"),\n     \
    \           existingCard(\"b\"),\n                existingCard(\"c\"),\n     \
    \           addCard(\"d\", \"4\"),\n                removeCard(\"c\"),\n     \
    \           removeNonExisting(\"xxxx\"),\n                addCard(\"c\", \"5\"\
    ),\n                existingDef(\"new card\", \"4\"),\n                existingDef(\"\
    f\", \"5\"),\n                removeCard(\"c\"),\n                removeCard(\"\
    d\"), // left only a and b\n                askCards(\"1\", \"2\", \"3\", \"4\"\
    , \"3\", \"2\", \"1\"), // try to fit random\n                askCards(\"2\"),\n\
    \                exit()\n        )\n        return tests\n    }\n\n    override\
    \ fun check(reply: String, clue: DialogClue): CheckResult {\n        return clue.checkOutput(reply)\n\
    \    }\n\n\n    // ------ extensions for building a dialog: ------\n\n    fun\
    \ inputAction(action: String) = compositePhrase {\n        listOf(containing(\"\
    action\", hint = \"This line should ask the action.\"), user(action))\n    }\n\
    \n    // extend dialog context with our own data:\n\n    @Suppress(\"UNCHECKED_CAST\"\
    )\n    private val Context.cardToDef\n        get() = rawData.getOrPut(\"cardToDef\"\
    ) { mutableMapOf<String, String>() } as MutableMap<String, String>\n\n    @Suppress(\"\
    UNCHECKED_CAST\")\n    private val Context.defToCard\n        get() = rawData.getOrPut(\"\
    defToCard\") { mutableMapOf<String, String>() } as MutableMap<String, String>\n\
    \n    private fun Context.addCard(card: String, definition: String) {\n      \
    \  cardToDef[card] = definition\n        defToCard[definition] = card\n    }\n\
    \n    private fun Context.removeCard(card: String) {\n        val def = cardToDef.remove(card)\n\
    \        if (def != null) {\n            defToCard.remove(def)\n        }\n  \
    \  }\n\n\n    private fun addCard(card: String, def: String) = compositePhrase(\n\
    \            inputAction(\"add\"),\n            anyLine(), user(card),\n     \
    \       anyLine(), user(def),\n            containing(\"has been added\",\n  \
    \                  hint = \"This line should add the pair (\\\"$card\\\":\\\"\
    $def\\\").\",\n                    updateContext = { ctx -> ctx.addCard(card,\
    \ def) })\n    )\n\n\n    private fun existingDef(card: String, def: String) =\
    \ compositePhrase(\n            inputAction(\"add\"),\n            anyLine(),\
    \ user(card),\n            anyLine(), user(def),\n            containing(\"definition\"\
    , \"exists\", hint = \"This line should reject the existing definition `$def`.\"\
    )\n    )\n\n\n    private fun existingCard(card: String) = compositePhrase(\n\
    \            inputAction(\"add\"),\n            anyLine(), user(card),\n     \
    \       containing(\"card\", \"exists\", hint = \"This line should reject the\
    \ existing card `$card`.\")\n    )\n\n    private fun removeCard(card: String)\
    \ = compositePhrase(\n            inputAction(\"remove\"),\n            anyLine(),\
    \ user(card),\n            containing(\"has been removed\", hint = \"This line\
    \ should remove the card `$card`.\",\n                    updateContext = { ctx\
    \ -> ctx.removeCard(card) })\n    )\n\n    private fun removeNonExisting(card:\
    \ String) = compositePhrase(\n            inputAction(\"remove\"),\n         \
    \   anyLine(), user(card),\n            containing(\"Can't remove \\\"$card\\\"\
    \", hint = \"This line should reject removing non existing card `$card`.\")\n\
    \    )\n\n\n    private fun importCards(fileName: String, vararg cards: Pair<String,\
    \ String>) = compositePhrase(\n            inputAction(\"import\"),\n        \
    \    anyLine(), user(fileName),\n            containing(\"${cards.size} cards\
    \ have been loaded\",\n                    updateContext = { ctx ->\n        \
    \                val cardToDef = ctx.cardToDef\n                        val defToCard\
    \ = ctx.defToCard\n                        cards.forEach { (card, def) ->\n  \
    \                          if (card in cardToDef) {\n                        \
    \        defToCard.remove(cardToDef[card]) // erase wrong reverse link\n     \
    \                       }\n                            ctx.addCard(card, def)\
    \ // with update!!\n                        }\n                    })\n    )\n\
    \n    private fun importNonExisting(fileName: String) = compositePhrase(\n   \
    \         inputAction(\"import\"),\n            anyLine(), user(fileName),\n \
    \           containing(\"not found\", hint = \"This line should say, that the\
    \ file $fileName does not exist.\")\n    )\n\n    private fun exportCards(fileName:\
    \ String, cardsSize: Int) = compositePhrase(\n            inputAction(\"export\"\
    ),\n            anyLine(), user(fileName),\n            containing(\"$cardsSize\
    \ cards have been saved\")\n    )\n\n    private fun exit() = compositePhrase(\n\
    \            inputAction(\"exit\"),\n            anyLine()\n    )\n\n    /** Perform\
    \ ask action. [ansDefs] are our test answers with definitions.\n     * We don't\
    \ know are they wrong or correct, because the test is random. */\n    private\
    \ fun askCards(vararg ansDefs: String) = compositePhrase {\n        val startPhrases\
    \ = listOf(\n                inputAction(\"ask\"),\n                anyLine(),\
    \ user(ansDefs.size.toString())\n        )\n        // here we add the dialog\
    \ logic, by creating base OutputLine class with a custom checker\n        // we\
    \ use context to connect with neighbor checkers\n\n        // iterate test answered\
    \ definitions:\n        val repeatingPhrases = ansDefs.map { ansDef ->\n     \
    \       compositePhrase(\n                    OutputLine { text, ctx ->\n    \
    \                    val askedCard = text.dropWhile { it != '\"' }.dropLastWhile\
    \ { it != '\"' }.trim('\"')\n                        if (askedCard.isEmpty())\
    \ {\n                            return@OutputLine CheckResult.wrong(\"Not found\
    \ card in quotes. \" +\n                                    \"This line should\
    \ ask the definition of a random card.\")\n                        }\n       \
    \                 if (askedCard !in ctx.cardToDef) {\n                       \
    \     return@OutputLine CheckResult.wrong(\"You asked the definition of the non\
    \ existing card: `$askedCard`.\")\n                        }\n               \
    \         ctx.rawData[\"lastAskedCard\"] = askedCard\n                       \
    \ CheckResult.correct();\n                    },\n                    // unfortunately\
    \ we can't access the Context in user action, see documentation of user()\n  \
    \                  user(ansDef),\n                    // check the answer:\n \
    \                   OutputLine { text, ctx ->\n                        val askedCard\
    \ = ctx.rawData[\"lastAskedCard\"]\n                                ?: throw IllegalStateException(\"\
    Not found lastAskedCard in the `ask` checker.\")\n                        val\
    \ cardToDef = ctx.cardToDef\n                        val defToCard = ctx.defToCard\n\
    \                        val rightAns = cardToDef[askedCard]\n\n             \
    \           val hint = \"The asked card was `$askedCard`, the answer was `$ansDef`.\"\
    \n                        if (cardToDef[askedCard] == ansDef)\n              \
    \              containing(\"Correct\", hint = hint).checker(text, ctx)\n     \
    \                   else {\n                            val isDefFor = defToCard[ansDef]\n\
    \                            if (isDefFor != null) {\n                       \
    \         containing(\"Wrong\", \"The right answer is \\\"$rightAns\\\"\",\n \
    \                                       \"but your definition is correct for \\\
    \"$isDefFor\\\"\", hint = hint).checker(text, ctx)\n                         \
    \   } else {\n                                // should not contain definition\
    \ hint!!\n                                if (text.contains(\"but your definition\
    \ is correct for\")) {\n                                    CheckResult.wrong(\"\
    Your line\\n`$text`\\nshould NOT contain \" +\n                              \
    \              \"`but your definition is correct for`.\\n$hint\")\n          \
    \                      } else {\n                                    containing(\"\
    Wrong\", \"The right answer is \\\"$rightAns\\\"\", hint = hint).checker(text,\
    \ ctx)\n                                }\n                                \n\
    \                            }\n                        }\n                  \
    \  }\n            )\n        }\n        (startPhrases + repeatingPhrases)\n  \
    \  }\n\n}\n\n"
  learner_created: false
feedback_link: https://hyperskill.org/projects/83/stages/461/implement
status: Failed
feedback:
  message: Failed to launch checking
  time: Tue, 05 Jan 2021 14:11:07 UTC
record: -1
